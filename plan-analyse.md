# План реализации автоматизации оплаты 80 гемов Brawl Stars через Supercell Store

## 1. Обзор задачи и критерий успеха
- **Задача**: реализовать устойчивый автоматизированный сценарий покупки **80 гемов** в Brawl Stars через **Supercell Store** с оплатой через **Google Pay**, с учётом VPN/прокси, ОТП по email и привязанной карты.
- **Критерий успеха**: один воспроизводимый "зелёный" путь:
  - запуск скрипта с локального ноутбука (подготовленный VPN + американский резидентский прокси);
  - переход на `store.supercell.com` → выбор нужной игры/товара → логин по email + ОТП;
  - добавление SKU "80 гемов" с количеством строго 1, переход к Checkout;
  - оплата через Google Pay (логин, пароль, backup code, подтверждение оплаты);
  - выход из Supercell-аккаунта и отвязка способа оплаты.

## 2. Технологический стек
- **Язык и раннер**:
  - Python 3.x;
  - Playwright for Python (`playwright` + `pytest-playwright`, по рекомендациям официальной документации Playwright и примеров из context7/exa);
  - `pytest` как основной тестовый раннер.
- **Инфраструктура и утилиты**:
  - `.env` для секретов (логины/пароли/backup codes, прокси);
  - при необходимости `config.yaml` или `toml` для не-секретной конфигурации (URL товара, игра, таймауты и т.п.);
  - логирование в текст/NDJSON + артефакты Playwright (скриншоты, видео, HAR).

## 3. Архитектура и структура проекта (по мотивам Nx/clean architecture)
- **Слои** (аналог домен/приложение/инфраструктура/тесты, как в Nx):
  - `domain` — бизнес-сценарий "покупка 80 гемов" как последовательность абстрактных шагов:
    - сущности: `BrawlStarsAccount`, `GoogleAccount`, `Order`, `Payment`;
    - сценарий: `purchase_80_gems(brawl_account, google_account, settings)` — без деталей DOM.
  - `application` — use-cases и оркестраторы:
    - `flows/purchase_80_gems_flow.py`: реализация сценария через вызовы адаптеров Playwright и конфигурации;
    - валидация входных параметров, маршрутизация ошибок.
  - `infrastructure` — адаптеры над внешними системами:
    - `browser/supercell_store_client.py` — навигация по Supercell Store (логин, выбор товара, корзина, аккаунт);
    - `browser/google_pay_client.py` — работа с окном/фреймом Google Pay (логин, 2FA, подтверждение);
    - `config/settings.py` — загрузка `.env` и других конфигов;
    - при расширении — клиент к почтовому сервису (чтение ОТП), но на первом шаге можно оставить ручной ввод.
  - `tests` — e2e и, при необходимости, unit:
    - `tests/e2e/test_purchase_80_gems.py` — основной сценарий покупки;
    - `tests/unit/` — точечные тесты на разбор конфигов/утилиты.
- **Предлагаемая структура каталогов**:
  - `src/domain/`
  - `src/application/flows/`
  - `src/infrastructure/browser/`
  - `src/infrastructure/config/`
  - `tests/e2e/`
  - `tests/unit/`

## 4. Подготовка окружения и базовый каркас проекта
1. **Инициализация репозитория**:
   - создать `requirements.txt` с базовыми зависимостями: `playwright`, `pytest`, `pytest-playwright`, `python-dotenv`, при необходимости — `pyyaml`;
   - настроить `.gitignore` под Python (уже есть) + артефакты Playwright.
2. **Установка Playwright**:
   - `pip install -r requirements.txt`;
   - `playwright install` для браузеров.
3. **Базовый e2e-тест** ("smoke"):
   - написать минимальный тест `tests/e2e/test_smoke_supercell_store.py`, который:
     - открывает `https://store.supercell.com/brawlstars` или нужную игру;
     - проверяет доступность страницы и базовых элементов.
   - убедиться, что тест запускается и стабильно проходит в текущем окружении (возможно, с учётом прокси в параметрах запуска браузера).

## 5. Конфигурация и секреты
1. **Определить формат `.env`**:
   - `BS_EMAIL` — email Brawl Stars;
   - `GOOGLE_EMAIL`, `GOOGLE_PASSWORD`, `GOOGLE_BACKUP_CODE` — для Google Pay;
   - `HTTP_PROXY`, `HTTPS_PROXY` или отдельные параметры типа `PROXY_HOST/PORT/LOGIN/PASSWORD`;
   - при необходимости флаги: `OTP_MODE=manual|email`.
2. **Конфигурационный модуль** `src/infrastructure/config/settings.py`:
   - загрузка `.env` через `python-dotenv`;
   - класс/датакласс `Settings` с валидированными полями (можно использовать pydantic или простую ручную валидацию);
   - значения по умолчанию и аккуратная обработка отсутствующих переменных (чёткие сообщения об ошибках).
3. **Не-секретный конфиг** (например, `config.yaml`):
   - базовые URL (игра, аккаунт, fallback-страницы);
   - целевой SKU (название/ID "80 гемов");
   - таймауты ожиданий Playwright (на основе best practices из docs и примеров context7/exa).

## 6. Детальный план реализации по этапам

### Этап 1. Инфраструктура браузера и прокси
- Реализовать модуль `supercell_store_client` с инициализацией контекста Playwright:
  - учесть передачу прокси в `browser_type.launch(...)` или `new_context(...)` (по официальной доке Playwright и примерам);
  - добавить возможность выбора браузера (Chromium по умолчанию).
- Добавить параметры:
  - время ожидания загрузки страниц;
  - стратегию автождания (использовать auto-wait Playwright, минимизировать `sleep`).

### Этап 2. Логин в Supercell Store (email + ОТП)
- В `supercell_store_client` реализовать методы:
  - `open_store(game_slug)` — открытие нужной игры (Brawl Stars/Clash Royale) с корректным URL;
  - `start_login(email)` — нажатие "Войти", ввод email, отправка запроса на ОТП;
  - `complete_login_with_otp(otp_code)` — ввод одноразового кода и подтверждение.
- На уровне `application/flows`:
  - сценарий, который запрашивает ОТП у пользователя (в консоли или через параметр запуска) на первом шаге;
  - предусмотреть будущую опцию интеграции с почтой (по найденным в exa примерам IMAP/интеграций OTP), но не реализовывать сразу.

### Этап 3. Выбор товара и корзина
- В `supercell_store_client` реализовать:
  - способ найти SKU "80 гемов":
    - либо по конфигу с прямой ссылкой на продукт;
    - либо по DOM (по названию/цене), учитывая, что URL товара может меняться (как указано в `plan.md`).
  - методы:
    - `go_to_product_80_gems()` — переход к нужному товару;
    - `add_to_cart_single_quantity()` — клик по Buy и проверка, что количество = 1 (при необходимости нажимать "−");
    - `proceed_to_checkout()` — переход на страницу оплаты и ожидание полной загрузки.

### Этап 4. Оплата через Google Pay
- В `google_pay_client` (инфраструктурный слой):
  - реализовать логику ожидания попапа/новой вкладки (`page.wait_for_event('popup')` или работа с фреймом);
  - реализовать шаги авторизации Google, опираясь на паттерны из статей exa про 2FA/TOTP/Google login и официальный пример Playwright auth:
    - ввод логина;
    - ввод пароля;
    - ввод backup-кода 2FA при необходимости;
    - подтверждение оплаты.
- На уровне потока `purchase_80_gems_flow`:
  - скоординировать `supercell_store_client` и `google_pay_client`, чтобы:
    - после `proceed_to_checkout()` выбрать Google Pay;
    - передать управление клиенту Google Pay;
    - дождаться подтверждения успешной оплаты или выбросить контролируемое исключение при ошибке.

### Этап 5. Выход и отвязка способа оплаты
- В `supercell_store_client` реализовать:
  - `open_account_page()` — переход на `https://store.supercell.com/account`;
  - `detach_payment_method()` — нахождение секции `Payment information` и удаление карты/способа оплаты (по кнопкам/ссылкам DOM);
  - `logout_supercell()` — поиск и клик по "Log out" / "Выйти из аккаунта Supercell".
- В потоке `purchase_80_gems_flow` добавить финализирующий блок:
  - попытка отвязки карты и логаута даже при частичных ошибках (насколько возможно);
  - логирование статуса каждого шага.

### Этап 6. Логирование и артефакты
- Определить единый формат логов (например, NDJSON по аналогии с `bs_helpers` в референсном репо из `plan.md`):
  - `event`, `stage`, `status`, `details`;
  - ключевые этапы: `vpn/proxy_ready`, `login_started`, `otp_entered`, `product_selected`, `checkout_opened`, `gpay_login`, `payment_confirmed`, `payment_detached`, `logout_done`.
- Настроить Playwright:
  - на снятие скриншотов при падении теста;
  - по возможности — запись видео (стандартная функция Playwright E2E).

### Этап 7. Тестирование и демонстрация
- **E2E-тест** `tests/e2e/test_purchase_80_gems.py`:
  - один основной тест, вызывающий `purchase_80_gems_flow` с параметрами из `Settings`;
  - проверка, что оплата прошла (по UI/подтверждению/отсутствию ошибок на странице);
  - проверка, что после сценария пользователь разлогинен и карта отвязана.
- **Негативные сценарии** (по возможности, но не обязательно на первом этапе):
  - неверный ОТП;
  - таймаут при загрузке Google Pay;
  - некорректный SKU.
- **README/отчёт**:
  - описать стек, шаги по запуску (`pip install`, `playwright install`, заполнение `.env`, запуск `pytest`);
  - указать, как настроить VPN/прокси (без деталей секретов);
  - описать, как интерпретировать логи и где смотреть скриншоты/видео.

## 7. Расширения и дальнейшее развитие
- Поддержка других SKU и игр (Brawl Pass, другие пакеты);
- Автоматизация получения ОТП из почты (по IMAP/API) по шаблонам из статей exa и официальных примеров;
- Интеграция с фермой устройств/облачной инфраструктурой (по аналогии с референсным репо BrowserStack из `plan.md`);
- Оборачивание сценария в CLI/сервисный слой (например, запуск по параметрам или HTTP API).

Этот план опирается на требования из `plan.md`, практики Playwright из официальной документации (через context7/Ref) и примеры OTP/2FA/checkout-флоу из exa, а также использует идеи разбиения по слоям из мира Nx/clean architecture, адаптированные под небольшой Python-проект.
